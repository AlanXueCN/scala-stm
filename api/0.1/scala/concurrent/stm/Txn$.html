<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>scala.concurrent.stm.Txn</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" rel="stylesheet" type="text/css" media="screen" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
    
        </head>
        <body class="value" onload="windowTitle();">

      <p id="owner"><a href="../../package.html" class="extype" name="scala">scala</a>.<a href="../package.html" class="extype" name="scala.concurrent">concurrent</a>.<a href="package.html" class="extype" name="scala.concurrent.stm">stm</a></p>

      <div id="definition">
        <img src="../../../lib/object_big.png" />
        <h1>Txn</h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="kind">object</span>
      <span class="symbol">
        <span class="name">Txn</span>
        
        
        <span class="result"> extends AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment" id="comment"><div class="comment cmt"><p>The <code>Txn</code> object provides methods that operate on the current transaction
 context.  These methods are only valid within an atomic block or a
 transaction life-cycle handler, which is checked at compile time by
 requiring that an implicit <code>InTxn</code> or <code>InTxnEnd</code> be available.
</p></div><div class="block">
            linear super types: AnyRef, <span class="extype" name="scala.Any">Any</span>
          </div>
            
            
            
          </div>

      <div id="template">

        <div id="mbrsel">
          <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
          <div id="order">
                <span class="filtertype">Ordering</span>
                <ol><li class="alpha in">Alphabetic</li><li class="inherit out">By inheritance</li></ol>
              </div>
          <div id="ancestors">
                <span class="filtertype">Inherited</span>
                <ol><li class="hideall">Hide All</li><li class="showall">Show all</li></ol>
                <ol id="linearization"><li class="in" name="scala.concurrent.stm.Txn">Txn</li><li class="in" name="scala.AnyRef">AnyRef</li><li class="in" name="scala.Any">Any</li></ol>
              </div>
          <div id="visbl">
              <span class="filtertype">Visibility</span>
              <ol><li class="public in">Public</li><li class="all out">All</li></ol>
            </div>
          <div id="impl">
              <span class="filtertype">Impl.</span>
              <ol><li class="concrete in">Concrete</li><li class="abstract in">Abstract</li></ol>
            </div>
        </div>

        

        <div class="types members" id="types">
              <h3>Type Members</h3>
              <ol><li visbl="pub" data-isabs="true" name="scala.concurrent.stm.Txn.ExternalDecider">
      <a id="ExternalDecider:ExternalDecider"></a>
      <h4 class="signature"><a href="Txn$$ExternalDecider.html">
      <span class="kind">trait</span>
      <span class="symbol">
        <span class="name">ExternalDecider</span>
        
        
        <span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      <p class="comment cmt">An <code>ExternalDecider</code> is given the final control over the decision of
 whether or not to commit a transaction, which allows two-phase commit to
 be integrated with a single non-transactional resource.</p>
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn.OptimisticFailureCause">
      <a id="OptimisticFailureCause:OptimisticFailureCause"></a>
      <h4 class="signature"><a href="Txn$$OptimisticFailureCause.html">
      <span class="kind">case class</span>
      <span class="symbol">
        <span class="name">OptimisticFailureCause</span>
        
        <span class="params">(<span name="category">category: Symbol</span>, <span name="trigger">trigger: Option[Any]</span>)</span>
        <span class="result"> extends TransientRollbackCause with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The <code>RollbackCause</code> for a <code>NestingLevel</code> whose optimistic execution was
 invalid, and that should be retried.</p>
    </li><li visbl="pub" data-isabs="true" name="scala.concurrent.stm.Txn.PermanentRollbackCause">
      <a id="PermanentRollbackCause:PermanentRollbackCause"></a>
      <h4 class="signature"><a href="Txn$$PermanentRollbackCause.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">PermanentRollbackCause</span>
        
        
        <span class="result"> extends RollbackCause</span>
      </span>
      </a></h4>
      <p class="comment cmt"><code>RollbackCause</code>s for which the failure is permanent and no attempt should
 be made to retry the underlying atomic block.</p>
    </li><li visbl="pub" data-isabs="true" name="scala.concurrent.stm.Txn.RollbackCause">
      <a id="RollbackCause:RollbackCause"></a>
      <h4 class="signature"><a href="Txn$$RollbackCause.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">RollbackCause</span>
        
        
        <span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      <p class="comment cmt">A record of the reason that a atomic block execution attempt was rolled
 back.</p>
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn.RolledBack">
      <a id="RolledBack:RolledBack"></a>
      <h4 class="signature"><a href="Txn$$RolledBack.html">
      <span class="kind">case class</span>
      <span class="symbol">
        <span class="name">RolledBack</span>
        
        <span class="params">(<span name="cause">cause: RollbackCause</span>)</span>
        <span class="result"> extends Status with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The <code>Status</code> for an atomic block execution attempt that is being or that
 has been cancelled.</p>
    </li><li visbl="pub" data-isabs="true" name="scala.concurrent.stm.Txn.Status">
      <a id="Status:Status"></a>
      <h4 class="signature"><a href="Txn$$Status.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">Status</span>
        
        
        <span class="result"> extends AnyRef</span>
      </span>
      </a></h4>
      <p class="comment cmt">The current state of an attempt to execute an atomic block.</p>
    </li><li visbl="pub" data-isabs="true" name="scala.concurrent.stm.Txn.TransientRollbackCause">
      <a id="TransientRollbackCause:TransientRollbackCause"></a>
      <h4 class="signature"><a href="Txn$$TransientRollbackCause.html">
      <span class="kind">class</span>
      <span class="symbol">
        <span class="name">TransientRollbackCause</span>
        
        
        <span class="result"> extends RollbackCause</span>
      </span>
      </a></h4>
      <p class="comment cmt"><code>RollbackCause</code>s for which the failure is transient and another attempt
 should be made to execute the underlying atomic block.</p>
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn.UncaughtExceptionCause">
      <a id="UncaughtExceptionCause:UncaughtExceptionCause"></a>
      <h4 class="signature"><a href="Txn$$UncaughtExceptionCause.html">
      <span class="kind">case class</span>
      <span class="symbol">
        <span class="name">UncaughtExceptionCause</span>
        
        <span class="params">(<span name="x">x: Throwable</span>)</span>
        <span class="result"> extends PermanentRollbackCause with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The <code>RollbackCause</code> for an atomic block that should not be restarted
 because it threw an exception.</p>
    </li></ol>
            </div>

        <div class="values members" id="values">
              <h3>Value Members</h3>
              <ol><li visbl="pub" data-isabs="false" name="scala.AnyRef#!=">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span>
        <span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
            
            <div class="fullcomment"><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div></div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.Any#!=">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">!=</span>
        
        <span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span>
        <span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt"><code>o != arg0</code> is the same as <code>!(o == (arg0))</code>.</p>
            <div class="fullcomment"><div class="comment cmt"><p><code>o != arg0</code> is the same as <code>!(o == (arg0))</code>.
</p></div><dl class="paramcmts block"><dt class="param">arg0</dt><dd class="cmt"><p>the object to compare against this object for dis-equality.</p></dd><dt>returns</dt><dd class="cmt"><p><code>false</code> if the receiver object is equivalent to the argument; <code>true</code> otherwise.</p></dd></dl><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: Any
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef###">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">##</span>
        
        <span class="params">()</span>
        <span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      
            
            <div class="fullcomment"><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef → Any
        </div></div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#$asInstanceOf">
      <a id="$asInstanceOf[T0]():T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">$asInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="params">()</span>
        <span class="result">: T0</span>
      </span>
      </h4>
      
            
            <div class="fullcomment"><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div></div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#$isInstanceOf">
      <a id="$isInstanceOf[T0]():Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">$isInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="params">()</span>
        <span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
            
            <div class="fullcomment"><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div></div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#==">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span>
        <span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt"><code>o == arg0</code> is the same as <code>if (o eq null) arg0 eq null else o.equals(arg0)</code>.</p>
            <div class="fullcomment"><div class="comment cmt"><p><code>o == arg0</code> is the same as <code>if (o eq null) arg0 eq null else o.equals(arg0)</code>.
</p></div><dl class="paramcmts block"><dt class="param">arg0</dt><dd class="cmt"><p>the object to compare against this object for equality.</p></dd><dt>returns</dt><dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.</p></dd></dl><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.Any#==">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">==</span>
        
        <span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span>
        <span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt"><code>o == arg0</code> is the same as <code>o.equals(arg0)</code>.</p>
            <div class="fullcomment"><div class="comment cmt"><p><code>o == arg0</code> is the same as <code>o.equals(arg0)</code>.
</p></div><dl class="paramcmts block"><dt class="param">arg0</dt><dd class="cmt"><p>the object to compare against this object for equality.</p></dd><dt>returns</dt><dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.</p></dd></dl><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: Any
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn.Active">
      <a id="Active:Active"></a>
      <h4 class="signature"><a href="Txn$$Active$.html">
      <span class="kind">object</span>
      <span class="symbol">
        <span class="name">Active</span>
        
        
        <span class="result"> extends Status with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The <code>Status</code> for a transaction nesting level that may perform <code>Ref</code> reads
 and writes, that is waiting for a child nesting level to complete, or
 that has been merged into an <code>Active</code> parent nesting level.</p>
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn.Committed">
      <a id="Committed:Committed"></a>
      <h4 class="signature"><a href="Txn$$Committed$.html">
      <span class="kind">object</span>
      <span class="symbol">
        <span class="name">Committed</span>
        
        
        <span class="result"> extends Status with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The <code>Status</code> for the nesting levels of a transaction that has been
 committed.</p>
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn.Committing">
      <a id="Committing:Committing"></a>
      <h4 class="signature"><a href="Txn$$Committing$.html">
      <span class="kind">object</span>
      <span class="symbol">
        <span class="name">Committing</span>
        
        
        <span class="result"> extends Status with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The <code>Status</code> for the nesting levels of a transaction that has decided to
 commit, but whose <code>Ref</code> writes are not yet visible to other threads.</p>
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn.ExplicitRetryCause">
      <a id="ExplicitRetryCause:ExplicitRetryCause"></a>
      <h4 class="signature"><a href="Txn$$ExplicitRetryCause$.html">
      <span class="kind">object</span>
      <span class="symbol">
        <span class="name">ExplicitRetryCause</span>
        
        
        <span class="result"> extends TransientRollbackCause with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The <code>RollbackCause</code> for an atomic block execution attempt that ended with
 a call to <code>retry</code>.</p>
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn.Prepared">
      <a id="Prepared:Prepared"></a>
      <h4 class="signature"><a href="Txn$$Prepared$.html">
      <span class="kind">object</span>
      <span class="symbol">
        <span class="name">Prepared</span>
        
        
        <span class="result"> extends Status with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The <code>Status</code> for the nesting levels of a transaction that has
 successfully acquired all write permissions necessary to succeed, and
 that has delegated the final commit decision to an external decider.</p>
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn.Preparing">
      <a id="Preparing:Preparing"></a>
      <h4 class="signature"><a href="Txn$$Preparing$.html">
      <span class="kind">object</span>
      <span class="symbol">
        <span class="name">Preparing</span>
        
        
        <span class="result"> extends Status with Product</span>
      </span>
      </a></h4>
      <p class="comment cmt">The <code>Status</code> for the nesting levels of a transaction that are attempting
 to commit, but for which the outcome is uncertain.</p>
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#afterCommit">
      <a id="afterCommit((Status) ⇒ Unit)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">afterCommit</span>
        
        <span class="params">(<span name="handler">handler: (<a href="Txn$$Status.html" class="extype" name="scala.concurrent.stm.Txn.Status">Status</a>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a href="InTxnEnd.html" class="extype" name="scala.concurrent.stm.InTxnEnd">InTxnEnd</a></span>)</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Arranges for <code>handler</code> to be executed as soon as possible after the
 current transaction is committed, if this nesting level is part of the
 overall transaction commit.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Arranges for <code>handler</code> to be executed as soon as possible after the
 current transaction is committed, if this nesting level is part of the
 overall transaction commit.  Details:</p><ul><li>no transaction will be active while the handler is run, but it may
   access <code>Ref</code>s using a new top-level atomic block or <code>.single</code>;</li><li>the handler runs after all internal locks have been released, so any
   values read or written in the transaction might already have been
   changed by another thread before the handler is executed;</li><li>handlers will be executed in their registration order; and</li><li>handlers may be registered so long as the current transaction status is
   not <code>RolledBack</code> or <code>Committed</code>.
</li></ul></div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#afterCompletion">
      <a id="afterCompletion((Status) ⇒ Unit)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">afterCompletion</span>
        
        <span class="params">(<span name="handler">handler: (<a href="Txn$$Status.html" class="extype" name="scala.concurrent.stm.Txn.Status">Status</a>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a href="InTxnEnd.html" class="extype" name="scala.concurrent.stm.InTxnEnd">InTxnEnd</a></span>)</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Arranges for <code>handler</code> to be called as both an after-commit and
 after-rollback handler.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Arranges for <code>handler</code> to be called as both an after-commit and
 after-rollback handler.</p><p> Equivalent to: </p><pre>
    afterCommit(handler)
    afterRollback(handler)
</pre></div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#afterRollback">
      <a id="afterRollback((Status) ⇒ Unit)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">afterRollback</span>
        
        <span class="params">(<span name="handler">handler: (<a href="Txn$$Status.html" class="extype" name="scala.concurrent.stm.Txn.Status">Status</a>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a href="InTxnEnd.html" class="extype" name="scala.concurrent.stm.InTxnEnd">InTxnEnd</a></span>)</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Arranges for <code>handler</code> to be executed as soon as possible after the
 current nesting level is rolled back.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Arranges for <code>handler</code> to be executed as soon as possible after the
 current nesting level is rolled back.  Details:</p><ul><li>the handler will be executed immediately during a partial rollback that
   includes the current nesting level;</li><li>the handler will be run before any additional attempts to execute the
   atomic block;</li><li>handlers will be run in the reverse of their registration order; and</li><li>handlers may be registered so long as the current transaction status is
   not <code>RolledBack</code> or <code>Committed</code>.
</li></ul></div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.Any#asInstanceOf">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">asInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        
        <span class="result">: T0</span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">This method is used to cast the receiver object to be of type <code>T0</code>.</p>
            <div class="fullcomment"><div class="comment cmt"><p>This method is used to cast the receiver object to be of type <code>T0</code>.</p><p>Note that the success of a cast at runtime is modulo Scala's erasure semantics.  Therefore the expression<code>1.asInstanceOf[String]</code> will throw a <code>ClassCastException</code> at runtime, while the expression<code>List(1).asInstanceOf[List[String]]</code> will not.  In the latter example, because the type argument is erased as
part of compilation it is not possible to check whether the contents of the list are of the requested typed.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the receiver object.</p></dd></dl><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: Any
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#beforeCommit">
      <a id="beforeCommit((InTxn) ⇒ Unit)(InTxn):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">beforeCommit</span>
        
        <span class="params">(<span name="handler">handler: (<a href="InTxn.html" class="extype" name="scala.concurrent.stm.InTxn">InTxn</a>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a href="InTxn.html" class="extype" name="scala.concurrent.stm.InTxn">InTxn</a></span>)</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Arranges for <code>handler</code> to be executed as late as possible while the root
 nesting level of the current transaction is still <code>Active</code>, unless the
 current nesting level is rolled back.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Arranges for <code>handler</code> to be executed as late as possible while the root
 nesting level of the current transaction is still <code>Active</code>, unless the
 current nesting level is rolled back.  Reads, writes and additional
 nested transactions may be performed inside the handler.  Details:</p><ul><li>it is possible that after <code>handler</code> is run the transaction might still
   be rolled back;</li><li>it is okay to call <code>beforeCommit</code> from inside <code>handler</code>, the
   reentrantly added handler will be included in this before-commit phase;
   and</li><li>before-commit handlers will be executed in their registration order.
</li></ul></div>
            
            
            
          </div>
          
    </li><li visbl="prt" data-isabs="false" name="scala.AnyRef#clone">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">clone</span>
        
        <span class="params">()</span>
        <span class="result">: AnyRef</span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">This method creates and returns a copy of the receiver object.</p>
            <div class="fullcomment"><div class="comment cmt"><p>This method creates and returns a copy of the receiver object.</p><p>The default implementation of the <code>clone</code> method is platform dependent.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a copy of the receiver object.</p></dd></dl><div class="block">
          attributes: protected 
        </div><div class="block">
          definition classes: AnyRef
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#eq">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">eq</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span>
        <span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">This method is used to test whether the argument (<code>arg0</code>) is a reference to the
receiver object (<code>this</code>).</p>
            <div class="fullcomment"><div class="comment cmt"><p>This method is used to test whether the argument (<code>arg0</code>) is a reference to the
receiver object (<code>this</code>).</p><p>The <code>eq</code> method implements an [http://en.wikipedia.org/wiki/Equivalence_relation equivalence relation] on
non-null instances of <code>AnyRef</code>:
 * It is reflexive: for any non-null instance <code>x</code> of type <code>AnyRef</code>, <code>x.eq(x)</code> returns <code>true</code>.
 * It is symmetric: for any non-null instances <code>x</code> and <code>y</code> of type <code>AnyRef</code>, <code>x.eq(y)</code> returns <code>true</code> if and
   only if <code>y.eq(x)</code> returns <code>true</code>.
 * It is transitive: for any non-null instances <code>x</code>, <code>y</code>, and <code>z</code> of type <code>AnyRef</code> if <code>x.eq(y)</code> returns <code>true</code>   and <code>y.eq(z)</code> returns <code>true</code>, then <code>x.eq(z)</code> returns <code>true</code>.</p><p>Additionally, the <code>eq</code> method has three other properties.
 * It is consistent: for any non-null instances <code>x</code> and <code>y</code> of type <code>AnyRef</code>, multiple invocations of
   <code>x.eq(y)</code> consistently returns <code>true</code> or consistently returns <code>false</code>.
 * For any non-null instance <code>x</code> of type <code>AnyRef</code>, <code>x.eq(null)</code> and <code>null.eq(x)</code> returns <code>false</code>.
 * <code>null.eq(null)</code> returns <code>true</code>.</p><p>When overriding the <code>equals</code> or <code>hashCode</code> methods, it is important to ensure that their behavior is
consistent with reference equality.  Therefore, if two objects are references to each other (<code>o1 eq o2</code>), they
should be equal to each other (<code>o1 == o2</code>) and they should hash to the same value (<code>o1.hashCode == o2.hashCode</code>).
</p></div><dl class="paramcmts block"><dt class="param">arg0</dt><dd class="cmt"><p>the object to compare against this object for reference equality.</p></dd><dt>returns</dt><dd class="cmt"><p><code>true</code> if the argument is a reference to the receiver object; <code>false</code> otherwise.</p></dd></dl><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#equals">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">equals</span>
        
        <span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span>
        <span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">This method is used to compare the receiver object (<code>this</code>) with the argument object (<code>arg0</code>) for equivalence.</p>
            <div class="fullcomment"><div class="comment cmt"><p>This method is used to compare the receiver object (<code>this</code>) with the argument object (<code>arg0</code>) for equivalence.</p><p>The default implementations of this method is an [http://en.wikipedia.org/wiki/Equivalence_relation equivalence
relation]:
 * It is reflexive: for any instance <code>x</code> of type <code>Any</code>, <code>x.equals(x)</code> should return <code>true</code>.
 * It is symmetric: for any instances <code>x</code> and <code>y</code> of type <code>Any</code>, <code>x.equals(y)</code> should return <code>true</code> if and
   only if <code>y.equals(x)</code> returns <code>true</code>.
 * It is transitive: for any instances <code>x</code>, <code>y</code>, and <code>z</code> of type <code>AnyRef</code> if <code>x.equals(y)</code> returns <code>true</code> and
   <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.</p><p>If you override this method, you should verify that your implementation remains an equivalence relation.
Additionally, when overriding this method it is often necessary to override <code>hashCode</code> to ensure that objects
that are &quot;equal&quot; (<code>o1.equals(o2)</code> returns <code>true</code>) hash to the same 
scala.Int
(<code>o1.hashCode.equals(o2.hashCode)</code>).
</p></div><dl class="paramcmts block"><dt class="param">arg0</dt><dd class="cmt"><p>the object to compare against this object for equality.</p></dd><dt>returns</dt><dd class="cmt"><p><code>true</code> if the receiver object is equivalent to the argument; <code>false</code> otherwise.</p></dd></dl><div class="block">
          definition classes: AnyRef → Any
        </div>
            
            
            
          </div>
          
    </li><li visbl="prt" data-isabs="false" name="scala.AnyRef#finalize">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">finalize</span>
        
        <span class="params">()</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">This method is called by the garbage collector on the receiver object when garbage collection determines that
there are no more references to the object.</p>
            <div class="fullcomment"><div class="comment cmt"><p>This method is called by the garbage collector on the receiver object when garbage collection determines that
there are no more references to the object.</p><p>The details of when and if the <code>finalize</code> method are invoked, as well as the interaction between <code>finalize</code>and non-local returns and exceptions, are all platform dependent.</p></div><div class="block">
          attributes: protected 
        </div><div class="block">
          definition classes: AnyRef
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#findCurrent">
      <a id="findCurrent(MaybeTxn):Option[InTxn]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">findCurrent</span>
        
        <span class="params">(<span class="implicit">implicit </span><span name="mt">mt: <a href="MaybeTxn.html" class="extype" name="scala.concurrent.stm.MaybeTxn">MaybeTxn</a></span>)</span>
        <span class="result">: <span class="extype" name="scala.Option">Option</span>[<a href="InTxn.html" class="extype" name="scala.concurrent.stm.InTxn">InTxn</a>]</span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Returns <code>Some(t)</code> if called from inside the static or dynamic scope of
 the transaction context <code>t</code>, <code>None</code> otherwise.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Returns <code>Some(t)</code> if called from inside the static or dynamic scope of
 the transaction context <code>t</code>, <code>None</code> otherwise.  If an implicit <code>InTxn</code> is
 available it may be used.
</p></div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#getClass">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">getClass</span>
        
        <span class="params">()</span>
        <span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Returns a representation that corresponds to the dynamic class of the receiver object.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Returns a representation that corresponds to the dynamic class of the receiver object.</p><p>The nature of the representation is platform dependent.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a representation that corresponds to the dynamic class of the receiver object.</p></dd></dl><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#hashCode">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">hashCode</span>
        
        <span class="params">()</span>
        <span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Returns a hash code value for the object.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Returns a hash code value for the object.</p><p>The default hashing algorithm is platform dependent.</p><p>Note that it is allowed for two objects to have identical hash codes (<code>o1.hashCode.equals(o2.hashCode)</code>) yet
not be equal (<code>o1.equals(o2)</code> returns <code>false</code>).  A degenerate implementation could always return <code>0</code>.
However, it is required that if two objects are equal (<code>o1.equals(o2)</code> returns <code>true</code>) that they have
identical hash codes (<code>o1.hashCode.equals(o2.hashCode)</code>).  Therefore, when overriding this method, be sure
to verify that the behavior is consistent with the <code>equals</code> method.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the hash code value for the object.</p></dd></dl><div class="block">
          definition classes: AnyRef → Any
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.Any#isInstanceOf">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">isInstanceOf</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        
        <span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">This method is used to test whether the dynamic type of the receiver object is <code>T0</code>.</p>
            <div class="fullcomment"><div class="comment cmt"><p>This method is used to test whether the dynamic type of the receiver object is <code>T0</code>.</p><p>Note that the test result of the test is modulo Scala's erasure semantics.  Therefore the expression<code>1.isInstanceOf[String]</code> will return <code>false</code>, while the expression <code>List(1).isInstanceOf[List[String]]</code> will
return <code>true</code>.  In the latter example, because the type argument is erased as part of compilation it is not
possible to check whether the contents of the list are of the requested typed.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p><code>true</code> if the receiver object is an instance of erasure of type <code>T0</code>; <code>false</code> otherwise.</p></dd></dl><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: Any
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#ne">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">ne</span>
        
        <span class="params">(<span name="arg0">arg0: AnyRef</span>)</span>
        <span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt"><code>o.ne(arg0)</code> is the same as <code>!(o.eq(arg0))</code>.</p>
            <div class="fullcomment"><div class="comment cmt"><p><code>o.ne(arg0)</code> is the same as <code>!(o.eq(arg0))</code>.
</p></div><dl class="paramcmts block"><dt class="param">arg0</dt><dd class="cmt"><p>the object to compare against this object for reference dis-equality.</p></dd><dt>returns</dt><dd class="cmt"><p><code>false</code> if the argument is not a reference to the receiver object; <code>true</code> otherwise.</p></dd></dl><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#notify">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">notify</span>
        
        <span class="params">()</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Wakes up a single thread that is waiting on the receiver object's monitor.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Wakes up a single thread that is waiting on the receiver object's monitor.</p></div><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#notifyAll">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">notifyAll</span>
        
        <span class="params">()</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Wakes up all threads that are waiting on the receiver object's monitor.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Wakes up all threads that are waiting on the receiver object's monitor.</p></div><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#retry">
      <a id="retry(InTxn):Nothing"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">retry</span>
        
        <span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a href="InTxn.html" class="extype" name="scala.concurrent.stm.InTxn">InTxn</a></span>)</span>
        <span class="result">: <span class="extype" name="scala.Nothing">Nothing</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Causes the current nesting level to roll back.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Causes the current nesting level to roll back.  It will not be retried
 until a write has been performed to some memory location read by this
 transaction.  If an alternative to this atomic block was provided via
 <code>orAtomic</code> or <code>atomic.oneOf</code>, then the alternative will be tried.</p></div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#rollback">
      <a id="rollback(RollbackCause)(InTxnEnd):Nothing"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">rollback</span>
        
        <span class="params">(<span name="cause">cause: <a href="Txn$$RollbackCause.html" class="extype" name="scala.concurrent.stm.Txn.RollbackCause">RollbackCause</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a href="InTxnEnd.html" class="extype" name="scala.concurrent.stm.InTxnEnd">InTxnEnd</a></span>)</span>
        <span class="result">: <span class="extype" name="scala.Nothing">Nothing</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Causes the current nesting level to be rolled back due to the specified
 <code>cause</code>.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Causes the current nesting level to be rolled back due to the specified
 <code>cause</code>.  This method may only be called by the thread executing the
 transaction; obtain a <code>NestingLevel</code> instance <code>n</code> and call
 <code>n.requestRollback(cause)</code> if you wish to doom a transaction from another
 thread.</p></div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#setExternalDecider">
      <a id="setExternalDecider(ExternalDecider)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">setExternalDecider</span>
        
        <span class="params">(<span name="decider">decider: <a href="Txn$$ExternalDecider.html" class="extype" name="scala.concurrent.stm.Txn.ExternalDecider">ExternalDecider</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a href="InTxnEnd.html" class="extype" name="scala.concurrent.stm.InTxnEnd">InTxnEnd</a></span>)</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">(rare) Delegates final decision of the outcome of the transaction to
 <code>decider</code> if the current nesting level participates in the top-level
 commit.</p>
            <div class="fullcomment"><div class="comment cmt"><p>(rare) Delegates final decision of the outcome of the transaction to
 <code>decider</code> if the current nesting level participates in the top-level
 commit.  This method can succeed with at most one value per top-level
 transaction.</p></div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#status">
      <a id="status(InTxnEnd):Status"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">status</span>
        
        <span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a href="InTxnEnd.html" class="extype" name="scala.concurrent.stm.InTxnEnd">InTxnEnd</a></span>)</span>
        <span class="result">: <a href="Txn$$Status.html" class="extype" name="scala.concurrent.stm.Txn.Status">Status</a></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Returns the status of the current nesting level of the current
 transaction, equivalent to <code>NestingLevel.current.status</code>.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Returns the status of the current nesting level of the current
 transaction, equivalent to <code>NestingLevel.current.status</code>.
</p></div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#synchronized">
      <a id="synchronized[T0](T0):T0"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">synchronized</span>
        <span class="tparams">[<span name="T0">T0</span>]</span>
        <span class="params">(<span name="arg0">arg0: T0</span>)</span>
        <span class="result">: T0</span>
      </span>
      </h4>
      
            
            <div class="fullcomment"><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div></div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#toString">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">toString</span>
        
        <span class="params">()</span>
        <span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">Returns a string representation of the object.</p>
            <div class="fullcomment"><div class="comment cmt"><p>Returns a string representation of the object.</p><p>The default representation is platform dependent.
</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a string representation of the object.</p></dd></dl><div class="block">
          definition classes: AnyRef → Any
        </div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#wait">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">wait</span>
        
        <span class="params">()</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            
            <div class="fullcomment"><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div></div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#wait">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            
            <div class="fullcomment"><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div></div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.AnyRef#wait">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">wait</span>
        
        <span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            
            <div class="fullcomment"><div class="block">
          attributes: final 
        </div><div class="block">
          definition classes: AnyRef
        </div></div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#whileCommitting">
      <a id="whileCommitting((InTxnEnd) ⇒ Unit)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">whileCommitting</span>
        
        <span class="params">(<span name="handler">handler: (<a href="InTxnEnd.html" class="extype" name="scala.concurrent.stm.InTxnEnd">InTxnEnd</a>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a href="InTxnEnd.html" class="extype" name="scala.concurrent.stm.InTxnEnd">InTxnEnd</a></span>)</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">(rare) Arranges for <code>handler</code> to be called after (if) it has been decided
 that the current transaction will commit, but before the writes made by
 the transaction have become available to other threads.</p>
            <div class="fullcomment"><div class="comment cmt"><p>(rare) Arranges for <code>handler</code> to be called after (if) it has been decided
 that the current transaction will commit, but before the writes made by
 the transaction have become available to other threads.  While-committing
 handlers can lead to scalability problems, because while this transaction
 is in the <code>Committing</code> state it might obstruct other transactions.
 Details:</p><ul><li>the handler must not access any <code>Ref</code>s, even using <code>Ref.single</code>;</li><li>handlers will be executed in their registration order; and</li><li>handlers may be registered so long as the current transaction status is
   not <code>RolledBack</code> or <code>Committed</code>.
</li></ul></div>
            
            
            
          </div>
          
    </li><li visbl="pub" data-isabs="false" name="scala.concurrent.stm.Txn#whilePreparing">
      <a id="whilePreparing((InTxnEnd) ⇒ Unit)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="kind">def</span>
      <span class="symbol">
        <span class="name">whilePreparing</span>
        
        <span class="params">(<span name="handler">handler: (<a href="InTxnEnd.html" class="extype" name="scala.concurrent.stm.InTxnEnd">InTxnEnd</a>) ⇒ <span class="extype" name="scala.Unit">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a href="InTxnEnd.html" class="extype" name="scala.concurrent.stm.InTxnEnd">InTxnEnd</a></span>)</span>
        <span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      
            <p class="shortcomment cmt">(rare) Arranges for <code>handler</code> to be called after the <code>Ref</code> reads and
 writes have been checked for serializability, but before the decision has
 been made to commit or roll back.</p>
            <div class="fullcomment"><div class="comment cmt"><p>(rare) Arranges for <code>handler</code> to be called after the <code>Ref</code> reads and
 writes have been checked for serializability, but before the decision has
 been made to commit or roll back.  While-preparing handlers can lead to
 scalability problems, because while this transaction is in the
 <code>Preparing</code> state it might obstruct other transactions.  Details:</p><ul><li>the handler must not access any <code>Ref</code>s, even using <code>Ref.single</code>;</li><li>handlers will be executed in their registration order; and</li><li>handlers may be registered while the transaction is active, or from a
   while-preparing callback during the <code>Preparing</code> phase.
</li></ul></div>
            
            
            
          </div>
          
    </li></ol>
            </div>

        <div class="parent" name="scala.AnyRef">
              <h3>Inherited from AnyRef</h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>

      </div>
      
      <div id="tooltip"></div>
      
    </body>
      </html>
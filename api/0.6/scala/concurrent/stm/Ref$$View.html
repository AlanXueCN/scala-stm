<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>View - scala.concurrent.stm.Ref.View</title>
          <meta name="description" content="View - scala.concurrent.stm.Ref.View" />
          <meta name="keywords" content="View scala.concurrent.stm.Ref.View" />
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link href="../../../lib/template.css" media="screen" type="text/css" rel="stylesheet" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
    
        </head>
        <body class="type">
      <div id="definition">
        <img src="../../../lib/trait_big.png" />
        <p id="owner"><a href="../../package.html" class="extype" name="scala">scala</a>.<a href="../package.html" class="extype" name="scala.concurrent">concurrent</a>.<a href="package.html" class="extype" name="scala.concurrent.stm">stm</a>.<a href="Ref$.html" class="extype" name="scala.concurrent.stm.Ref">Ref</a></p>
        <h1>View</h1>
      </div>

      <h4 id="signature" class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <span class="name">View</span><span class="tparams">[<span name="A">A</span>]</span><span class="result"> extends <a href="Source$$View.html" class="extype" name="scala.concurrent.stm.Source.View">View</a>[A] with <a href="Sink$$View.html" class="extype" name="scala.concurrent.stm.Sink.View">View</a>[A]</span>
      </span>
      </h4>
      
          <div id="comment" class="fullcommenttop"><div class="comment cmt"><p><code>Ref.View</code> provides access to the contents of a <code>Ref</code> without requiring
 that an implicit <code>InTxn</code> be available.  When called from within the
 dynamic scope of a transaction, <code>View</code>'s methods operate as part of that
 transaction.  When there is no transaction active <code>View</code>'s methods are
 still atomic, but only for the duration of the method call.</p><p> A mental model of <code>View</code> is that <code>view.foo(args)</code> acts like
 <code>atomic { implicit t =&gt; view.ref.foo(args) }</code>.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent"><a href="Sink$$View.html" class="extype" name="scala.concurrent.stm.Sink.View">View</a>[A], <a href="Source$$View.html" class="extype" name="scala.concurrent.stm.Source.View">View</a>[A], AnyRef, <span class="extype" name="scala.Any">Any</span></div>
        </div></div>
        

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input id="mbrsel-input" type="text" accesskey="/" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
            </div>
        <div id="ancestors">
                <span class="filtertype">Inherited<br />
                </span>
                <ol id="linearization">
                  <li class="in" name="scala.concurrent.stm.Ref.View"><span>View</span></li><li class="in" name="scala.concurrent.stm.Sink.View"><span>View</span></li><li class="in" name="scala.concurrent.stm.Source.View"><span>View</span></li><li class="in" name="scala.AnyRef"><span>AnyRef</span></li><li class="in" name="scala.Any"><span>Any</span></li>
                </ol>
              </div><div id="ancestors">
            <span class="filtertype"></span>
            <ol>
              <li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li>
            </ol>
            <a href="docs.scala-lang.org/overviews/scaladoc/usage.html#members" target="_blank">Learn more about member selection</a>
          </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        

        <div id="values" class="values members">
              <h3>Abstract Value Members</h3>
              <ol><li name="scala.concurrent.stm.Source.View#await" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="await((A) ⇒ Boolean):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">await</span><span class="params">(<span name="f">f: (A) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Blocks until <code>f(get)</code> is true, in a manner consistent with the current
 context.</p><div class="fullcomment"><div class="comment cmt"><p>Blocks until <code>f(get)</code> is true, in a manner consistent with the current
 context.  Requires that the predicate be safe to reevaluate, and that
 <code>f(x) == f(y)</code> if <code>x == y</code>.</p><p> <code>v.await(f)</code> is equivalent to </p><pre>atomic { <span class="kw">implicit</span> t <span class="kw">=&gt;</span>
<span class="kw">if</span> (!f(v.get)) retry
}</pre><p> If you want to wait for a predicate that involves more than one <code>Ref</code>
 then use <code>retry</code> directly.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>a predicate that is safe to evaluate multiple times.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Source$$View.html" class="extype" name="scala.concurrent.stm.Source.View">View</a></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#compareAndSet" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="compareAndSet(A,A):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">compareAndSet</span><span class="params">(<span name="before">before: A</span>, <span name="after">after: A</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Equivalent to atomically executing
 <code>(if (before == get) { set(after); true } else false)</code>, but may be more
 efficient, especially if there is no enclosing atomic block.</p><div class="fullcomment"><div class="comment cmt"><p>Equivalent to atomically executing
 <code>(if (before == get) { set(after); true } else false)</code>, but may be more
 efficient, especially if there is no enclosing atomic block.</p></div><dl class="paramcmts block"><dt class="param">before</dt><dd class="cmt"><p>a value to compare against the <code>ref</code>'s contents using the
     value's <code>==</code> method.</p></dd><dt class="param">after</dt><dd class="cmt"><p>a value to store if <code>before</code> was equal to the previous
     contents.</p></dd><dt>returns</dt><dd class="cmt"><p>true if <code>before</code> was equal to the previous value of the viewed
     <code>Ref</code>, false otherwise.
</p></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#compareAndSetIdentity" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="compareAndSetIdentity[B&lt;:A](B,A):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">compareAndSetIdentity</span><span class="tparams">[<span name="B">B &lt;: A</span>]</span><span class="params">(<span name="before">before: B</span>, <span name="after">after: A</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Equivalent to atomically executing
 <code>(if (before eq get) { set(after); true } else false)</code>, but may be more
 efficient, especially if there is no enclosing atomic block.</p><div class="fullcomment"><div class="comment cmt"><p>Equivalent to atomically executing
 <code>(if (before eq get) { set(after); true } else false)</code>, but may be more
 efficient, especially if there is no enclosing atomic block.</p></div><dl class="paramcmts block"><dt class="param">before</dt><dd class="cmt"><p>a value to compare against the <code>ref</code>'s contents using
     reference identity equality (<code>eq</code>).</p></dd><dt class="param">after</dt><dd class="cmt"><p>a value to store if <code>before</code> was <code>eq</code> to the previous
     contents.</p></dd><dt>returns</dt><dd class="cmt"><p>true if <code>before</code> was <code>eq</code> to the previous value of the viewed
     <code>Ref</code>, false otherwise.
</p></dd></dl></div>
    </li><li name="scala.concurrent.stm.Source.View#get" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="get:A"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">get</span><span class="result">: A</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Performs an atomic read; equivalent to <code>apply()</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Performs an atomic read; equivalent to <code>apply()</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the value of the <code>Ref</code> as observed by the current context.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Source$$View.html" class="extype" name="scala.concurrent.stm.Source.View">View</a></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#getAndTransform" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="getAndTransform((A) ⇒ A):A"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getAndTransform</span><span class="params">(<span name="f">f: (A) ⇒ A</span>)</span><span class="result">: A</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Atomically replaces the value <i>v</i> stored in the <code>Ref</code> with
 <code>f</code>(<i>v</i>), returning the old value.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically replaces the value <i>v</i> stored in the <code>Ref</code> with
 <code>f</code>(<i>v</i>), returning the old value.  <code>transform</code> should be preferred
 if the return value is not needed, since it gives the STM more
 flexibility to avoid transaction conflicts.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>a function that is safe to call multiple times, and safe to
     call later during any enclosing atomic block.</p></dd><dt>returns</dt><dd class="cmt"><p>the previous value of the viewed <code>Ref</code>.
</p></dd></dl></div>
    </li><li name="scala.concurrent.stm.Source.View#getWith" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="getWith[Z]((A) ⇒ Z):Z"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getWith</span><span class="tparams">[<span name="Z">Z</span>]</span><span class="params">(<span name="f">f: (A) ⇒ Z</span>)</span><span class="result">: Z</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Acts like <code>ref.getWith(f)</code> if there is an active transaction, otherwise
 just returns <code>f(get)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Acts like <code>ref.getWith(f)</code> if there is an active transaction, otherwise
 just returns <code>f(get)</code>.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>an idempotent function.</p></dd><dt>returns</dt><dd class="cmt"><p>the result of applying <code>f</code> to the value contained in <code>ref</code>.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Source$$View.html" class="extype" name="scala.concurrent.stm.Source.View">View</a></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#ref" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="ref:Ref[A]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ref</span><span class="result">: <a href="Ref.html" class="extype" name="scala.concurrent.stm.Ref">Ref</a>[A]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns a <code>Ref</code> that accesses the same memory location as this view.</p><div class="fullcomment"><div class="comment cmt"><p>Returns a <code>Ref</code> that accesses the same memory location as this view.
 The returned <code>Ref</code> might be the original reference that was used to
 construct this view, or it might be a <code>Ref</code> that is equivalent (and
 <code>==</code>) to the original.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>a <code>Ref</code> that accesses the same memory location as this view.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="" class="extype" name="scala.concurrent.stm.Ref.View">View</a> → <a href="Sink$$View.html" class="extype" name="scala.concurrent.stm.Sink.View">View</a> → <a href="Source$$View.html" class="extype" name="scala.concurrent.stm.Source.View">View</a></dd></dl></div>
    </li><li name="scala.concurrent.stm.Source.View#relaxedGet" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="relaxedGet((A, A) ⇒ Boolean):A"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">relaxedGet</span><span class="params">(<span name="equiv">equiv: (A, A) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: A</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Acts like <code>ref.relaxedGet(equiv)</code> if there is an active transaction,
 otherwise just returns <code>get</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Acts like <code>ref.relaxedGet(equiv)</code> if there is an active transaction,
 otherwise just returns <code>get</code>.</p></div><dl class="paramcmts block"><dt class="param">equiv</dt><dd class="cmt"><p>an equivalence function that returns true if a transaction
     that observed the first argument will still complete correctly,
     where the second argument is the actual value that should have been
     observed.</p></dd><dt>returns</dt><dd class="cmt"><p>a value of the <code>Ref</code>, not necessary consistent with the rest of
     the reads performed by the active transaction, if any.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Source$$View.html" class="extype" name="scala.concurrent.stm.Source.View">View</a></dd></dl></div>
    </li><li name="scala.concurrent.stm.Sink.View#set" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="set(A):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">set</span><span class="params">(<span name="v">v: A</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Performs an atomic write; equivalent to <code>update(v)</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Performs an atomic write; equivalent to <code>update(v)</code>.</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Sink$$View.html" class="extype" name="scala.concurrent.stm.Sink.View">View</a></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#swap" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="swap(A):A"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">swap</span><span class="params">(<span name="v">v: A</span>)</span><span class="result">: A</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Works like <code>set(v)</code>, but returns the old value.</p><div class="fullcomment"><div class="comment cmt"><p>Works like <code>set(v)</code>, but returns the old value.  This is an
 atomic swap, equivalent to atomically performing a <code>get</code>
 followed by <code>set(v)</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the previous value held by <code>ref</code>.
</p></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#transform" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="transform((A) ⇒ A):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transform</span><span class="params">(<span name="f">f: (A) ⇒ A</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Atomically replaces the value <i>v</i> stored in the <code>Ref</code> with
 <code>f</code>(<i>v</i>).</p><div class="fullcomment"><div class="comment cmt"><p>Atomically replaces the value <i>v</i> stored in the <code>Ref</code> with
 <code>f</code>(<i>v</i>).  Some <code>Ref</code> implementations may defer execution of <code>f</code> or
 call <code>f</code> multiple times to avoid transaction conflicts.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>a function that is safe to call multiple times, and safe to
     call later during the enclosing atomic block, if any.
</p></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#transformAndGet" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="transformAndGet((A) ⇒ A):A"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transformAndGet</span><span class="params">(<span name="f">f: (A) ⇒ A</span>)</span><span class="result">: A</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Atomically replaces the value <i>v</i> stored in the <code>Ref</code> with
 <code>f</code>(<i>v</i>), returning the new value.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically replaces the value <i>v</i> stored in the <code>Ref</code> with
 <code>f</code>(<i>v</i>), returning the new value.  <code>transform</code> should be preferred
 if the return value is not needed, since it gives the STM more
 flexibility to avoid transaction conflicts.</p></div><dl class="paramcmts block"><dt class="param">f</dt><dd class="cmt"><p>a function that is safe to call multiple times, and safe to
     call later during any enclosing atomic block.</p></dd><dt>returns</dt><dd class="cmt"><p>the new value of the viewed <code>Ref</code>.
</p></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#transformIfDefined" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="transformIfDefined(PartialFunction[A, A]):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">transformIfDefined</span><span class="params">(<span name="pf">pf: <span class="extype" name="scala.PartialFunction">PartialFunction</span>[A, A]</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Atomically replaces the value <i>v</i> stored in the <code>Ref</code> with
 <code>pf</code>(<i>v</i>) if <code>pf.isDefinedAt</code>(<i>v</i>), returning true, otherwise
 leaves the element unchanged and returns false.</p><div class="fullcomment"><div class="comment cmt"><p>Atomically replaces the value <i>v</i> stored in the <code>Ref</code> with
 <code>pf</code>(<i>v</i>) if <code>pf.isDefinedAt</code>(<i>v</i>), returning true, otherwise
 leaves the element unchanged and returns false.  <code>pf.apply</code> and
 <code>pf.isDefinedAt</code> might be invoked multiple times by the STM, and might
 be called later in any enclosing atomic block.</p></div><dl class="paramcmts block"><dt class="param">pf</dt><dd class="cmt"><p>a partial function that is safe to call multiple times, and
     safe to call later during any enclosing atomic block.</p></dd><dt>returns</dt><dd class="cmt"><p><code>pf.isDefinedAt</code><code>(<i>v</i>), where <i>v</i> is the element held by
     this </code>Ref<code> on entry.
</code></p></dd></dl></div>
    </li><li name="scala.concurrent.stm.Source.View#tryAwait" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="tryAwait(Long,TimeUnit)((A) ⇒ Boolean):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">tryAwait</span><span class="params">(<span name="timeout">timeout: <span class="extype" name="scala.Long">Long</span></span>, <span name="unit">unit: <span class="extype" name="java.util.concurrent.TimeUnit">TimeUnit</span> = <span class="symbol"><span class="name"><a href="../../../java/package.html">TimeUnit.MILLISECONDS</a></span></span></span>)</span><span class="params">(<span name="f">f: (A) ⇒ <span class="extype" name="scala.Boolean">Boolean</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Blocks until <code>f(get)</code> is true and returns true, or returns false if
 the condition does not become true within within the specified timeout.</p><div class="fullcomment"><div class="comment cmt"><p>Blocks until <code>f(get)</code> is true and returns true, or returns false if
 the condition does not become true within within the specified timeout.</p><p> <code>v.tryAwait(timeout)(f)</code> is equivalent to </p><pre>atomic { <span class="kw">implicit</span> t <span class="kw">=&gt;</span>
f(v.get) || { retryFor(timeout) ; <span class="kw">false</span> }
}</pre></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>the maximum amount of time to wait, in units of <code>unit</code>.</p></dd><dt class="param">unit</dt><dd class="cmt"><p>the units in which the timeout is measured, defaulting to
     milliseconds.</p></dd><dt class="param">f</dt><dd class="cmt"><p>a predicate that is safe to evaluate multiple times.</p></dd><dt>returns</dt><dd class="cmt"><p>true if the predicate was satisfied, false if the wait timed
     out.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Source$$View.html" class="extype" name="scala.concurrent.stm.Source.View">View</a></dd></dl></div>
    </li><li name="scala.concurrent.stm.Sink.View#trySet" visbl="pub" data-isabs="true" fullComment="yes">
      <a id="trySet(A):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">abstract </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">trySet</span><span class="params">(<span name="v">v: A</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Performs an atomic write and returns true, or returns false.</p><div class="fullcomment"><div class="comment cmt"><p>Performs an atomic write and returns true, or returns false.  The
 STM implementation may choose to return false to reduce (not
 necessarily avoid) blocking.  If no other threads are performing any
 transactional or atomic accesses then this method will succeed.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Sink$$View.html" class="extype" name="scala.concurrent.stm.Sink.View">View</a></dd></dl></div>
    </li></ol>
            </div>

        <div id="values" class="values members">
              <h3>Concrete Value Members</h3>
              <ol><li name="scala.AnyRef#!=" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#!=" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $bang$eq" class="name">!=</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef###" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $hash$hash" class="name">##</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#*=" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="*=(A)(Numeric[A]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $times$eq" class="name">*=</span><span class="params">(<span name="rhs">rhs: A</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: Numeric[A]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Transforms the value stored in the <code>Ref</code> by multiplying it.</p><div class="fullcomment"><div class="comment cmt"><p>Transforms the value stored in the <code>Ref</code> by multiplying it.</p><p> <b>Note: Implementations may choose to ignore the provided <code>Numeric[A]</code>
 instance if <code>A</code> is a primitive type.</b>
</p></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>the quantity by which to multiple the value of <code>ref</code>.
</p></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#+=" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="+=(A)(Numeric[A]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $plus$eq" class="name">+=</span><span class="params">(<span name="rhs">rhs: A</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: Numeric[A]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Transforms the value stored in the <code>Ref</code> by incrementing it.</p><div class="fullcomment"><div class="comment cmt"><p>Transforms the value stored in the <code>Ref</code> by incrementing it.</p><p> <b>Note: Implementations may choose to ignore the provided <code>Numeric[A]</code>
 instance if <code>A</code> is a primitive type.</b>
</p></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>the quantity by which to increment the value of <code>ref</code>.
</p></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#-=" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="-=(A)(Numeric[A]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $minus$eq" class="name">-=</span><span class="params">(<span name="rhs">rhs: A</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: Numeric[A]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Transforms the value stored in the <code>Ref</code> by decrementing it.</p><div class="fullcomment"><div class="comment cmt"><p>Transforms the value stored in the <code>Ref</code> by decrementing it.</p><p> <b>Note: Implementations may choose to ignore the provided <code>Numeric[A]</code>
 instance if <code>A</code> is a primitive type.</b>
</p></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>the quantity by which to decrement the value of <code>ref</code>.
</p></dd></dl></div>
    </li><li name="scala.concurrent.stm.Ref.View#/=" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="/=(A)(Numeric[A]):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $div$eq" class="name">/=</span><span class="params">(<span name="rhs">rhs: A</span>)</span><span class="params">(<span class="implicit">implicit </span><span name="num">num: Numeric[A]</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Transforms the value stored in <code>ref</code> by performing a division on it,
 throwing away the remainder if division is not exact for instances of
 type <code>A</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Transforms the value stored in <code>ref</code> by performing a division on it,
 throwing away the remainder if division is not exact for instances of
 type <code>A</code>.  The careful reader will note that division is actually
 provided by <code>Fractional[A]</code> or <code>Integral[A]</code>, it is not defined on
 <code>Numeric[A]</code>.  To avoid compile-time ambiguity this method accepts a
 <code>Numeric[A]</code> and assumes that it can be converted at runtime into
 either a <code>Fractional[A]</code> or an <code>Integral[A]</code>.</p><p> <b>Note: Implementations may choose to ignore the provided <code>Numeric[A]</code>
 instance if <code>A</code> is a primitive type.</b>
</p></div><dl class="paramcmts block"><dt class="param">rhs</dt><dd class="cmt"><p>the quantity by which to divide the value of <code>ref</code>.
</p></dd></dl></div>
    </li><li name="scala.AnyRef#==" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.Any#==" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span title="gt4s: $eq$eq" class="name">==</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.concurrent.stm.Source.View#apply" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="apply():A"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">apply</span><span class="params">()</span><span class="result">: A</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Performs an atomic read of the value in <code>ref</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Performs an atomic read of the value in <code>ref</code>.  If an atomic block is
 active (see <code>Txn.findCurrent</code>) then the read will be performed as part
 of the transaction, otherwise it will act as if it was performed inside
 a new atomic block.  Equivalent to <code>get</code>.</p></div><dl class="paramcmts block"><dt>returns</dt><dd class="cmt"><p>the value of the <code>Ref</code> as observed by the current context.
</p></dd></dl><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Source$$View.html" class="extype" name="scala.concurrent.stm.Source.View">View</a></dd></dl></div>
    </li><li name="scala.Any#asInstanceOf" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#clone" visbl="prt" data-isabs="false" fullComment="yes">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java/lang/package.html" class="extype" name="java.lang">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#eq" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#equals" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Any">Any</span></span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#finalize" visbl="prt" data-isabs="false" fullComment="yes">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a href="../../../java/lang/package.html" class="extype" name="java.lang">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#getClass" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="getClass():Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.AnyRef#hashCode" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Int">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.Any#isInstanceOf" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li name="scala.AnyRef#ne" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span class="extype" name="scala.Boolean">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notify" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#notifyAll" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#synchronized" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li name="scala.AnyRef#toString" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span class="extype" name="java.lang.String">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li name="scala.concurrent.stm.Sink.View#update" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="update(A):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">update</span><span class="params">(<span name="v">v: A</span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Performs an atomic write of the value in <code>ref</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Performs an atomic write of the value in <code>ref</code>.  If an atomic block
 is active (see <code>Txn.findCurrent</code>) then the write will be performed
 as part of the transaction, otherwise it will act as if it was
 performed inside a new atomic block.  Equivalent to <code>set(v)</code>.
</p></div><dl class="attributes block"> <dt>Definition Classes</dt><dd><a href="Sink$$View.html" class="extype" name="scala.concurrent.stm.Sink.View">View</a></dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>, <span name="arg1">arg1: <span class="extype" name="scala.Int">Int</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li name="scala.AnyRef#wait" visbl="pub" data-isabs="false" fullComment="yes">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span class="extype" name="scala.Long">Long</span></span>)</span><span class="result">: <span class="extype" name="scala.Unit">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li></ol>
            </div>

        
        </div>

        <div id="inheritedMembers">
        <div class="parent" name="scala.concurrent.stm.Sink.View">
              <h3>Inherited from <a href="Sink$$View.html" class="extype" name="scala.concurrent.stm.Sink.View">View</a>[A]</h3>
            </div><div class="parent" name="scala.concurrent.stm.Source.View">
              <h3>Inherited from <a href="Source$$View.html" class="extype" name="scala.concurrent.stm.Source.View">View</a>[A]</h3>
            </div><div class="parent" name="scala.AnyRef">
              <h3>Inherited from AnyRef</h3>
            </div><div class="parent" name="scala.Any">
              <h3>Inherited from <span class="extype" name="scala.Any">Any</span></h3>
            </div>
        
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>
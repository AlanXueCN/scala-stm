<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
        <head>
          <title>scala.concurrent.stm.Txn</title>
          <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
          
      <link type="text/css" media="screen" rel="stylesheet" href="../../../lib/template.css" />
      <script type="text/javascript" src="../../../lib/jquery.js"></script>
      <script type="text/javascript" src="../../../lib/jquery-ui.js"></script>
      <script type="text/javascript" src="../../../lib/template.js"></script>
      <script type="text/javascript" src="../../../lib/tools.tooltip.js"></script>
    
        </head>
        <body onload="sh_highlightDocument('../lib/', '.min.js');" class="value">
      <div id="definition">
        <img src="../../../lib/object_big.png" />
        <p id="owner"><a name="scala" class="extype" href="../../package.html">scala</a>.<a name="scala.concurrent" class="extype" href="../package.html">concurrent</a>.<a name="scala.concurrent.stm" class="extype" href="package.html">stm</a></p>
        <h1>Txn</h1>
      </div>

      <h4 class="signature" id="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <span class="name">Txn</span><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      
      <div class="fullcommenttop" id="comment"><div class="comment cmt"><p>The <code>Txn</code> object provides methods that operate on the current transaction
 context.  These methods are only valid within an atomic block or a
 transaction life-cycle handler, which is checked at compile time by
 requiring that an implicit <code>InTxn</code> or <code>InTxnEnd</code> be available.
</p></div><div class="toggleContainer block">
          <span class="toggle">Linear Supertypes</span>
          <div class="superTypes hiddenContent">AnyRef, <span name="scala.Any" class="extype">Any</span></div>
        </div></div>
    

      <div id="mbrsel">
        <div id="textfilter"><span class="pre"></span><span class="input"><input accesskey="/" type="text" /></span><span class="post"></span></div>
        <div id="order">
              <span class="filtertype">Ordering</span>
              <ol><li class="alpha in"><span>Alphabetic</span></li><li class="inherit out"><span>By inheritance</span></li></ol>
            </div>
        <div id="ancestors">
              <span class="filtertype">Inherited</span>
              <ol><li class="hideall out"><span>Hide All</span></li>
              <li class="showall in"><span>Show all</span></li></ol>
              <ol id="linearization"><li name="scala.concurrent.stm.Txn" class="in"><span>Txn</span></li><li name="scala.AnyRef" class="in"><span>AnyRef</span></li><li name="scala.Any" class="in"><span>Any</span></li></ol>
            </div>
        <div id="visbl">
            <span class="filtertype">Visibility</span>
            <ol><li class="public in"><span>Public</span></li><li class="all out"><span>All</span></li></ol>
          </div>
      </div>

      <div id="template">
        <div id="allMembers">
        

        <div class="types members" id="types">
              <h3>Type Members</h3>
              <ol><li visbl="pub" name="scala.concurrent.stm.Txn.ExplicitRetryCause" data-isabs="false">
      <a id="ExplicitRetryCause:ExplicitRetryCause"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="Txn$$ExplicitRetryCause.html"><span class="name">ExplicitRetryCause</span></a><span class="params">(<span name="timeoutNanos">timeoutNanos: Option[Long]</span>)</span><span class="result"> extends TransientRollbackCause with Product with Serializable</span>
      </span>
      </h4>
      <p class="comment cmt">The <code>RollbackCause</code> for an atomic block execution attempt that ended with
 a call to <code>retry</code> or <code>retryFor</code>.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.ExternalDecider" data-isabs="true">
      <a id="ExternalDecider:ExternalDecider"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">trait</span>
      </span>
      <span class="symbol">
        <a href="Txn$$ExternalDecider.html"><span class="name">ExternalDecider</span></a><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      <p class="comment cmt">An <code>ExternalDecider</code> is given the final control over the decision of
 whether or not to commit a transaction, which allows two-phase commit to
 be integrated with a single non-transactional resource.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.OptimisticFailureCause" data-isabs="false">
      <a id="OptimisticFailureCause:OptimisticFailureCause"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="Txn$$OptimisticFailureCause.html"><span class="name">OptimisticFailureCause</span></a><span class="params">(<span name="category">category: Symbol</span>, <span name="trigger">trigger: Option[Any]</span>)</span><span class="result"> extends TransientRollbackCause with Product with Serializable</span>
      </span>
      </h4>
      <p class="comment cmt">The <code>RollbackCause</code> for a <code>NestingLevel</code> whose optimistic execution was
 invalid, and that should be retried.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.PermanentRollbackCause" data-isabs="true">
      <a id="PermanentRollbackCause:PermanentRollbackCause"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="Txn$$PermanentRollbackCause.html"><span class="name">PermanentRollbackCause</span></a><span class="result"> extends RollbackCause</span>
      </span>
      </h4>
      <p class="comment cmt"><code>RollbackCause</code>s for which the failure is permanent and no attempt should
 be made to retry the underlying atomic block.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.RollbackCause" data-isabs="true">
      <a id="RollbackCause:RollbackCause"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="Txn$$RollbackCause.html"><span class="name">RollbackCause</span></a><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      <p class="comment cmt">A record of the reason that a atomic block execution attempt was rolled
 back.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.RolledBack" data-isabs="false">
      <a id="RolledBack:RolledBack"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="Txn$$RolledBack.html"><span class="name">RolledBack</span></a><span class="params">(<span name="cause">cause: RollbackCause</span>)</span><span class="result"> extends Status with Product with Serializable</span>
      </span>
      </h4>
      <p class="comment cmt">The <code>Status</code> for an atomic block execution attempt that is being or that
 has been cancelled.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.Status" data-isabs="true">
      <a id="Status:Status"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="Txn$$Status.html"><span class="name">Status</span></a><span class="result"> extends AnyRef</span>
      </span>
      </h4>
      <p class="comment cmt">The current state of an attempt to execute an atomic block.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.TransientRollbackCause" data-isabs="true">
      <a id="TransientRollbackCause:TransientRollbackCause"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">sealed abstract </span>
        <span class="kind">class</span>
      </span>
      <span class="symbol">
        <a href="Txn$$TransientRollbackCause.html"><span class="name">TransientRollbackCause</span></a><span class="result"> extends RollbackCause</span>
      </span>
      </h4>
      <p class="comment cmt"><code>RollbackCause</code>s for which the failure is transient and another attempt
 should be made to execute the underlying atomic block.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.UncaughtExceptionCause" data-isabs="false">
      <a id="UncaughtExceptionCause:UncaughtExceptionCause"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">case class</span>
      </span>
      <span class="symbol">
        <a href="Txn$$UncaughtExceptionCause.html"><span class="name">UncaughtExceptionCause</span></a><span class="params">(<span name="x">x: Throwable</span>)</span><span class="result"> extends PermanentRollbackCause with Product with Serializable</span>
      </span>
      </h4>
      <p class="comment cmt">The <code>RollbackCause</code> for an atomic block that should not be restarted
 because it threw an exception.</p>
    </li></ol>
            </div>

        

        <div class="values members" id="values">
              <h3>Value Members</h3>
              <ol><li visbl="pub" name="scala.AnyRef#!=" data-isabs="false">
      <a id="!=(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#!=" data-isabs="false">
      <a id="!=(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $bang$eq">!=</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef###" data-isabs="false">
      <a id="##():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $hash$hash">##</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#==" data-isabs="false">
      <a id="==(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#==" data-isabs="false">
      <a id="==(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name" title="gt4s: $eq$eq">==</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.Active" data-isabs="false">
      <a id="Active:Active"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Txn$$Active$.html"><span class="name">Active</span></a><span class="result"> extends Status with Product with Serializable</span>
      </span>
      </h4>
      <p class="comment cmt">The <code>Status</code> for a transaction nesting level that may perform <code>Ref</code> reads
 and writes, that is waiting for a child nesting level to complete, or
 that has been merged into an <code>Active</code> parent nesting level.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.Committed" data-isabs="false">
      <a id="Committed:Committed"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Txn$$Committed$.html"><span class="name">Committed</span></a><span class="result"> extends Status with Product with Serializable</span>
      </span>
      </h4>
      <p class="comment cmt">The <code>Status</code> for the nesting levels of a transaction that has been
 committed.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.Committing" data-isabs="false">
      <a id="Committing:Committing"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Txn$$Committing$.html"><span class="name">Committing</span></a><span class="result"> extends Status with Product with Serializable</span>
      </span>
      </h4>
      <p class="comment cmt">The <code>Status</code> for the nesting levels of a transaction that has decided to
 commit, but whose <code>Ref</code> writes are not yet visible to other threads.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.Prepared" data-isabs="false">
      <a id="Prepared:Prepared"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Txn$$Prepared$.html"><span class="name">Prepared</span></a><span class="result"> extends Status with Product with Serializable</span>
      </span>
      </h4>
      <p class="comment cmt">The <code>Status</code> for the nesting levels of a transaction that has
 successfully acquired all write permissions necessary to succeed, and
 that has delegated the final commit decision to an external decider.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn.Preparing" data-isabs="false">
      <a id="Preparing:Preparing"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">object</span>
      </span>
      <span class="symbol">
        <a href="Txn$$Preparing$.html"><span class="name">Preparing</span></a><span class="result"> extends Status with Product with Serializable</span>
      </span>
      </h4>
      <p class="comment cmt">The <code>Status</code> for the nesting levels of a transaction that are attempting
 to commit, but for which the outcome is uncertain.</p>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#afterCommit" data-isabs="false">
      <a id="afterCommit((Status) ⇒ Unit)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">afterCommit</span><span class="params">(<span name="handler">handler: (<a name="scala.concurrent.stm.Txn.Status" class="extype" href="Txn$$Status.html">Status</a>) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxnEnd" class="extype" href="InTxnEnd.html">InTxnEnd</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Arranges for <code>handler</code> to be executed as soon as possible after the
 current transaction is committed, if this nesting level is part of the
 overall transaction commit.</p><div class="fullcomment"><div class="comment cmt"><p>Arranges for <code>handler</code> to be executed as soon as possible after the
 current transaction is committed, if this nesting level is part of the
 overall transaction commit.  Details:</p><ul><li>no transaction will be active while the handler is run, but it may
   access <code>Ref</code>s using a new top-level atomic block or <code>.single</code>;</li><li>the handler runs after all internal locks have been released, so any
   values read or written in the transaction might already have been
   changed by another thread before the handler is executed;</li><li>handlers will be executed in their registration order; and</li><li>handlers may be registered so long as the current transaction status is
   not <code>RolledBack</code> or <code>Committed</code>.
</li></ul></div></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#afterCompletion" data-isabs="false">
      <a id="afterCompletion((Status) ⇒ Unit)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">afterCompletion</span><span class="params">(<span name="handler">handler: (<a name="scala.concurrent.stm.Txn.Status" class="extype" href="Txn$$Status.html">Status</a>) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxnEnd" class="extype" href="InTxnEnd.html">InTxnEnd</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Arranges for <code>handler</code> to be called as both an after-commit and
 after-rollback handler.</p><div class="fullcomment"><div class="comment cmt"><p>Arranges for <code>handler</code> to be called as both an after-commit and
 after-rollback handler.</p><p> Equivalent to: </p><pre>
    afterRollback(handler)
    afterCommit(handler)
</pre></div></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#afterRollback" data-isabs="false">
      <a id="afterRollback((Status) ⇒ Unit)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">afterRollback</span><span class="params">(<span name="handler">handler: (<a name="scala.concurrent.stm.Txn.Status" class="extype" href="Txn$$Status.html">Status</a>) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxnEnd" class="extype" href="InTxnEnd.html">InTxnEnd</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Arranges for <code>handler</code> to be executed as soon as possible after the
 current nesting level is rolled back, or runs the handler immediately if
 the current nesting level's status is already <code>RolledBack</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Arranges for <code>handler</code> to be executed as soon as possible after the
 current nesting level is rolled back, or runs the handler immediately if
 the current nesting level's status is already <code>RolledBack</code>.  Details:</p><ul><li>the handler will be executed during any partial rollback that includes
   the current nesting level;</li><li>the handler will be run before any additional attempts to execute the
   atomic block;</li><li>handlers will be run in the reverse of their registration order; and</li><li>handlers may be registered so long as the current transaction status is
   not <code>Committed</code>.
</li></ul></div></div>
    </li><li visbl="pub" name="scala.Any#asInstanceOf" data-isabs="false">
      <a id="asInstanceOf[T0]:T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">asInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#beforeCommit" data-isabs="false">
      <a id="beforeCommit((InTxn) ⇒ Unit)(InTxn):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">beforeCommit</span><span class="params">(<span name="handler">handler: (<a name="scala.concurrent.stm.InTxn" class="extype" href="InTxn.html">InTxn</a>) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxn" class="extype" href="InTxn.html">InTxn</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Arranges for <code>handler</code> to be executed as late as possible while the root
 nesting level of the current transaction is still <code>Active</code>, unless the
 current nesting level is rolled back.</p><div class="fullcomment"><div class="comment cmt"><p>Arranges for <code>handler</code> to be executed as late as possible while the root
 nesting level of the current transaction is still <code>Active</code>, unless the
 current nesting level is rolled back.  Reads, writes and additional
 nested transactions may be performed inside the handler.  Details:</p><ul><li>it is possible that after <code>handler</code> is run the transaction might still
   be rolled back;</li><li>it is okay to call <code>beforeCommit</code> from inside <code>handler</code>, the
   reentrantly added handler will be included in this before-commit phase;
   and</li><li>before-commit handlers will be executed in their registration order.
</li></ul></div></div>
    </li><li visbl="prt" name="scala.AnyRef#clone" data-isabs="false">
      <a id="clone():AnyRef"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">clone</span><span class="params">()</span><span class="result">: AnyRef</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#eq" data-isabs="false">
      <a id="eq(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">eq</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#equals" data-isabs="false">
      <a id="equals(Any):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">equals</span><span class="params">(<span name="arg0">arg0: <span name="scala.Any" class="extype">Any</span></span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="prt" name="scala.AnyRef#finalize" data-isabs="false">
      <a id="finalize():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">finalize</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Attributes</dt><dd>protected[<a name="java.lang" class="extype" href="../../../java/lang/package.html">lang</a>] </dd><dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#findCurrent" data-isabs="false">
      <a id="findCurrent(MaybeTxn):Option[InTxn]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">findCurrent</span><span class="params">(<span class="implicit">implicit </span><span name="mt">mt: <a name="scala.concurrent.stm.MaybeTxn" class="extype" href="MaybeTxn.html">MaybeTxn</a></span>)</span><span class="result">: <span name="scala.Option" class="extype">Option</span>[<a name="scala.concurrent.stm.InTxn" class="extype" href="InTxn.html">InTxn</a>]</span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns <code>Some(t)</code> if called from inside the static or dynamic scope of
 the transaction context <code>t</code>, <code>None</code> otherwise.</p><div class="fullcomment"><div class="comment cmt"><p>Returns <code>Some(t)</code> if called from inside the static or dynamic scope of
 the transaction context <code>t</code>, <code>None</code> otherwise.  If an implicit <code>InTxn</code> is
 available it may be used.
</p></div></div>
    </li><li visbl="pub" name="scala.AnyRef#getClass" data-isabs="false">
      <a id="getClass():java.lang.Class[_]"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">getClass</span><span class="params">()</span><span class="result">: java.lang.Class[_]</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#hashCode" data-isabs="false">
      <a id="hashCode():Int"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">hashCode</span><span class="params">()</span><span class="result">: <span name="scala.Int" class="extype">Int</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.Any#isInstanceOf" data-isabs="false">
      <a id="isInstanceOf[T0]:Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">isInstanceOf</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#ne" data-isabs="false">
      <a id="ne(AnyRef):Boolean"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">ne</span><span class="params">(<span name="arg0">arg0: AnyRef</span>)</span><span class="result">: <span name="scala.Boolean" class="extype">Boolean</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notify" data-isabs="false">
      <a id="notify():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notify</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#notifyAll" data-isabs="false">
      <a id="notifyAll():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">notifyAll</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#retry" data-isabs="false">
      <a id="retry(InTxn):Nothing"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">retry</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxn" class="extype" href="InTxn.html">InTxn</a></span>)</span><span class="result">: <span name="scala.Nothing" class="extype">Nothing</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Rolls back the current nesting level for modular blocking.</p><div class="fullcomment"><div class="comment cmt"><p>Rolls back the current nesting level for modular blocking.  It will be
 retried, but only after some memory location observed by this transaction
 has been changed.  If any alternatives to this atomic block were provided
 via <code>orAtomic</code> or <code>atomic.oneOf</code>, then the alternative will be tried
 before blocking.</p></div><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt">IllegalStateException<p>if the transaction is not active.
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#retryFor" data-isabs="false">
      <a id="retryFor(Long,TimeUnit)(InTxn):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">retryFor</span><span class="params">(<span name="timeout">timeout: <span name="scala.Long" class="extype">Long</span></span>, <span name="unit">unit: <span name="java.util.concurrent.TimeUnit" class="extype">TimeUnit</span> = <span class="symbol"><span class="name"><a href="../../../java/package.html">TimeUnit.MILLISECONDS</a></span></span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxn" class="extype" href="InTxn.html">InTxn</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Causes the transaction to roll back and retry using modular blocking with
 a timeout, or returns immediately if the timeout has already expired.</p><div class="fullcomment"><div class="comment cmt"><p>Causes the transaction to roll back and retry using modular blocking with
 a timeout, or returns immediately if the timeout has already expired.
 The STM keeps track of the total amount of blocking that has occurred
 during modular blocking; this time is apportioned among the calls to
 <code>View.tryAwait</code> and <code>retryFor</code> that are part of the current attempt.
 <code>retryFor(0)</code> is a no-op.</p><p> Returns only if the timeout has expired.</p></div><dl class="paramcmts block"><dt class="param">timeout</dt><dd class="cmt"><p>the maximum amount of time that this <code>retryFor</code> should
     block, in units of <code>unit</code>.</p></dd><dt class="param">unit</dt><dd class="cmt"><p>the units in which to measure <code>timeout</code>, by default
     milliseconds.
</p></dd></dl></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#rollback" data-isabs="false">
      <a id="rollback(RollbackCause)(InTxnEnd):Nothing"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">rollback</span><span class="params">(<span name="cause">cause: <a name="scala.concurrent.stm.Txn.RollbackCause" class="extype" href="Txn$$RollbackCause.html">RollbackCause</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxnEnd" class="extype" href="InTxnEnd.html">InTxnEnd</a></span>)</span><span class="result">: <span name="scala.Nothing" class="extype">Nothing</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Causes the current nesting level to be rolled back due to the specified
 <code>cause</code>.</p><div class="fullcomment"><div class="comment cmt"><p>Causes the current nesting level to be rolled back due to the specified
 <code>cause</code>.  This method may only be called by the thread executing the
 transaction; obtain a <code>NestingLevel</code> instance <code>n</code> and call
 <code>n.requestRollback(cause)</code> if you wish to doom a transaction from another
 thread.</p></div><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt">IllegalStateException<p>if the current transaction has already
     decided to commit.
</p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#setExternalDecider" data-isabs="false">
      <a id="setExternalDecider(ExternalDecider)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">setExternalDecider</span><span class="params">(<span name="decider">decider: <a name="scala.concurrent.stm.Txn.ExternalDecider" class="extype" href="Txn$$ExternalDecider.html">ExternalDecider</a></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxnEnd" class="extype" href="InTxnEnd.html">InTxnEnd</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">(rare) Delegates final decision of the outcome of the transaction to
 <code>decider</code> if the current nesting level participates in the top-level
 commit.</p><div class="fullcomment"><div class="comment cmt"><p>(rare) Delegates final decision of the outcome of the transaction to
 <code>decider</code> if the current nesting level participates in the top-level
 commit.  This method can succeed with at most one value per top-level
 transaction.</p></div><dl class="attributes block"> <dt>Exceptions thrown</dt><dd><span class="cmt">IllegalArgumentException<p>if <code>setExternalDecider(d)</code> was
     previously called in this transaction, <code>d != decider</code>, and the
     nesting level from which <code>setExternalDecider(d)</code> was called has not
     rolled back.
</p></span><span class="cmt">IllegalStateException<p>if the current transaction's status is not
     <code>Active</code> or <code>Preparing</code></p></span></dd></dl></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#status" data-isabs="false">
      <a id="status(InTxnEnd):Status"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">status</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxnEnd" class="extype" href="InTxnEnd.html">InTxnEnd</a></span>)</span><span class="result">: <a name="scala.concurrent.stm.Txn.Status" class="extype" href="Txn$$Status.html">Status</a></span>
      </span>
      </h4>
      <p class="shortcomment cmt">Returns the status of the current nesting level of the current
 transaction, equivalent to <code>NestingLevel.current.status</code>.</p>
    </li><li visbl="pub" name="scala.AnyRef#synchronized" data-isabs="false">
      <a id="synchronized[T0](⇒ T0):T0"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">synchronized</span><span class="tparams">[<span name="T0">T0</span>]</span><span class="params">(<span name="arg0">arg0: ⇒ T0</span>)</span><span class="result">: T0</span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#toString" data-isabs="false">
      <a id="toString():String"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">toString</span><span class="params">()</span><span class="result">: <span name="java.lang.String" class="extype">String</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef → Any</dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait():Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">()</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long,Int):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>, <span name="arg1">arg1: <span name="scala.Int" class="extype">Int</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.AnyRef#wait" data-isabs="false">
      <a id="wait(Long):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier">final </span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">wait</span><span class="params">(<span name="arg0">arg0: <span name="scala.Long" class="extype">Long</span></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <div class="fullcomment"><dl class="attributes block"> <dt>Definition Classes</dt><dd>AnyRef</dd><dt>Annotations</dt><dd>
                <span class="name">@throws</span><span class="args">()</span>
              
        </dd></dl></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#whileCommitting" data-isabs="false">
      <a id="whileCommitting((InTxnEnd) ⇒ Unit)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">whileCommitting</span><span class="params">(<span name="handler">handler: (<a name="scala.concurrent.stm.InTxnEnd" class="extype" href="InTxnEnd.html">InTxnEnd</a>) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxnEnd" class="extype" href="InTxnEnd.html">InTxnEnd</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">(rare) Arranges for <code>handler</code> to be called after (if) it has been decided
 that the current transaction will commit, but before the writes made by
 the transaction have become available to other threads.</p><div class="fullcomment"><div class="comment cmt"><p>(rare) Arranges for <code>handler</code> to be called after (if) it has been decided
 that the current transaction will commit, but before the writes made by
 the transaction have become available to other threads.  While-committing
 handlers can lead to scalability problems, because while this transaction
 is in the <code>Committing</code> state it might obstruct other transactions.
 Details:</p><ul><li>the handler must not access any <code>Ref</code>s, even using <code>Ref.single</code>;</li><li>handlers will be executed in their registration order; and</li><li>handlers may be registered so long as the current transaction status is
   not <code>RolledBack</code> or <code>Committed</code>.
</li></ul></div></div>
    </li><li visbl="pub" name="scala.concurrent.stm.Txn#whilePreparing" data-isabs="false">
      <a id="whilePreparing((InTxnEnd) ⇒ Unit)(InTxnEnd):Unit"></a>
      <h4 class="signature">
      <span class="modifier_kind">
        <span class="modifier"></span>
        <span class="kind">def</span>
      </span>
      <span class="symbol">
        <span class="name">whilePreparing</span><span class="params">(<span name="handler">handler: (<a name="scala.concurrent.stm.InTxnEnd" class="extype" href="InTxnEnd.html">InTxnEnd</a>) ⇒ <span name="scala.Unit" class="extype">Unit</span></span>)</span><span class="params">(<span class="implicit">implicit </span><span name="txn">txn: <a name="scala.concurrent.stm.InTxnEnd" class="extype" href="InTxnEnd.html">InTxnEnd</a></span>)</span><span class="result">: <span name="scala.Unit" class="extype">Unit</span></span>
      </span>
      </h4>
      <p class="shortcomment cmt">(rare) Arranges for <code>handler</code> to be called after the <code>Ref</code> reads and
 writes have been checked for serializability, but before the decision has
 been made to commit or roll back.</p><div class="fullcomment"><div class="comment cmt"><p>(rare) Arranges for <code>handler</code> to be called after the <code>Ref</code> reads and
 writes have been checked for serializability, but before the decision has
 been made to commit or roll back.  While-preparing handlers can lead to
 scalability problems, because while this transaction is in the
 <code>Preparing</code> state it might obstruct other transactions.  Details:</p><ul><li>the handler must not access any <code>Ref</code>s, even using <code>Ref.single</code>;</li><li>handlers will be executed in their registration order; and</li><li>handlers may be registered while the transaction is active, or from a
   while-preparing callback during the <code>Preparing</code> phase.
</li></ul></div></div>
    </li></ol>
            </div>

        
        </div>

        <div id="inheritedMembers">
        <div name="scala.AnyRef" class="parent">
              <h3>Inherited from AnyRef</h3>
            </div><div name="scala.Any" class="parent">
              <h3>Inherited from <span name="scala.Any" class="extype">Any</span></h3>
            </div>
        </div>

      </div>

      <div id="tooltip"></div>

      <div id="footer">  </div>


    </body>
      </html>